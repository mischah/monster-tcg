// Monster TCG Game Logic

class Monster {
    constructor(name, emoji, attack, defense, health, rarity, description, image = null) {
        this.id = Math.random().toString(36).substr(2, 9);
        this.name = name;
        this.emoji = emoji;
        this.image = image || name.toLowerCase()
            .replace(/ä/g, 'ae')
            .replace(/ö/g, 'oe')
            .replace(/ü/g, 'ue')
            .replace(/ß/g, 'ss')
            .replace(/[^a-z0-9]/g, '');
        this.attack = attack;
        this.defense = defense;
        this.health = health;
        this.maxHealth = health;
        this.rarity = rarity;
        this.description = description;
    }

    takeDamage(damage) {
        const actualDamage = Math.max(1, damage - this.defense);
        this.health = Math.max(0, this.health - actualDamage);
        return actualDamage;
    }

    isAlive() {
        return this.health > 0;
    }

    heal() {
        this.health = this.maxHealth;
    }
}

class Game {
    constructor() {
        this.coins = 100;
        this.collection = [];
        this.deck = [];
        this.maxDeckSize = 10;
        this.currentBattleMonster = null;
        this.enemyMonster = null;
        this.battleInProgress = false;
        
        // Lade gespeicherte Daten oder initialisiere Starter-Karten
        this.loadGameData();
        this.initializeEventListeners();
        this.updateDisplay();
        
        // Initialisiere Booster Displays
        this.initializeBoosterDisplays();
        
        // Initialisiere Drag & Drop für Deck Builder
        this.initializeDragAndDrop();
        
        // Auto-Save alle 5 Sekunden
        this.startAutoSave();
    }

    // Monster-Datenbank
    getRandomMonster() {
        const monsters = [
            // Häufige Monster
            { name: "Feuerdrache", image: "feuerdrache", emoji: "🐉", attack: 25, defense: 15, health: 80, rarity: "common", description: "Ein kleiner aber mutiger Drache mit feurigem Temperament." },
            { name: "Waldgeist", image: "waldgeist", emoji: "🌲", attack: 20, defense: 20, health: 90, rarity: "common", description: "Ein friedlicher Waldgeist, der die Natur beschützt." },
            { name: "Blitzwolf", image: "blitzwolf", emoji: "⚡", attack: 30, defense: 10, health: 70, rarity: "common", description: "Schnell wie der Blitz und genauso gefährlich." },
            { name: "Steingigant", image: "steingigant", emoji: "🗿", attack: 15, defense: 30, health: 120, rarity: "common", description: "Langsam aber unglaublich robust und stark." },
            { name: "Wasserschlange", image: "wasserschlange", emoji: "🌊", attack: 22, defense: 18, health: 85, rarity: "common", description: "Gleitet durch Wasser wie durch Luft." },
            
            // Seltene Monster
            { name: "Kristallbär", image: "kristallbaer", emoji: "💎", attack: 35, defense: 25, health: 110, rarity: "rare", description: "Mit Kristallen gepanzerter Bär von magischer Macht." },
            { name: "Schattenrabe", image: "schattenrabe", emoji: "🌙", attack: 40, defense: 15, health: 95, rarity: "rare", description: "Meister der Schatten und nächtlicher Jäger." },
            { name: "Flammenphönix", image: "flammenphoenix", emoji: "🔥", attack: 45, defense: 20, health: 100, rarity: "rare", description: "Wiedergeboren aus der Asche mit erneuterter Macht." },
            { name: "Eiswächter", image: "eiswaechter", emoji: "❄️", attack: 30, defense: 35, health: 130, rarity: "rare", description: "Hüter der ewigen Gletscher des Nordens." },
            
            // Epische Monster
            { name: "Sternendrache", image: "sternendrache", emoji: "⭐", attack: 55, defense: 30, health: 150, rarity: "epic", description: "Ein legendärer Drache, der die Macht der Sterne nutzt." },
            { name: "Urzeittytan", image: "urzeittytan", emoji: "🦕", attack: 50, defense: 40, health: 180, rarity: "epic", description: "Ein Gigant aus vergangenen Zeitaltern." },
            { name: "Geisterherr", image: "geisterherr", emoji: "👻", attack: 60, defense: 20, health: 120, rarity: "epic", description: "Beherrscher der Unterwelt und Geister." },
            
            // Legendäre Monster
            { name: "Regenbogeneinhorn", image: "regenbogeneinhorn", emoji: "🦄", attack: 70, defense: 50, health: 200, rarity: "legendary", description: "Das seltenste und mächtigste aller magischen Wesen." },
            { name: "Kosmosdrache", image: "kosmosdrache", emoji: "🌌", attack: 80, defense: 45, health: 220, rarity: "legendary", description: "Hüter des Universums mit unermesslicher Macht." },
            { name: "Zeitwächter", image: "zeitwaechter", emoji: "⏰", attack: 75, defense: 55, health: 250, rarity: "legendary", description: "Manipuliert die Zeit selbst und ist quasi unsterblich." }
        ];

        return monsters[Math.floor(Math.random() * monsters.length)];
    }

    // Seltenheits-basierte Zufallsgenerierung
    getRandomMonsterByRarity(guaranteedRarity = null) {
        let rarity;
        
        if (guaranteedRarity) {
            rarity = guaranteedRarity;
        } else {
            const rand = Math.random();
            if (rand < 0.6) rarity = "common";      // 60%
            else if (rand < 0.85) rarity = "rare"; // 25%
            else if (rand < 0.97) rarity = "epic"; // 12%
            else rarity = "legendary";              // 3%
        }

        const monsters = [];
        for (let i = 0; i < 50; i++) { // Genug Versuche
            const monster = this.getRandomMonster();
            if (monster.rarity === rarity) {
                return new Monster(
                    monster.name,
                    monster.emoji,
                    monster.attack,
                    monster.defense,
                    monster.health,
                    monster.rarity,
                    monster.description
                );
            }
        }
        
        // Fallback
        const fallback = this.getRandomMonster();
        return new Monster(
            fallback.name,
            fallback.emoji,
            fallback.attack,
            fallback.defense,
            fallback.health,
            fallback.rarity,
            fallback.description
        );
    }

    initializeStarterCards() {
        // Starter-Deck mit 5 Karten
        for (let i = 0; i < 5; i++) {
            this.collection.push(this.getRandomMonsterByRarity("common"));
        }
    }

    initializeEventListeners() {
        // Tab-Navigation
        document.querySelectorAll('.nav-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                const tab = e.target.dataset.tab;
                this.switchTab(tab);
            });
        });

        // Filter und Suche
        document.getElementById('rarity-filter').addEventListener('change', () => {
            this.filterCards();
        });

        document.getElementById('search-cards').addEventListener('input', () => {
            this.filterCards();
        });

        // Restock Button
        document.getElementById('restock-btn').addEventListener('click', () => {
            this.restockBoosterDisplays();
        });

        // Import Save Button
        document.getElementById('import-save-btn').addEventListener('click', () => {
            document.getElementById('import-save-input').click();
        });

        document.getElementById('import-save-input').addEventListener('change', (e) => {
            this.importSaveData(e.target.files[0]);
        });

        // Save/Load Controls
        document.getElementById('manual-save-btn').addEventListener('click', () => {
            this.manualSave();
        });

        document.getElementById('export-save-btn').addEventListener('click', () => {
            this.exportSaveData();
        });

        document.getElementById('reset-game-btn').addEventListener('click', () => {
            this.resetGame();
        });

        // Deck Builder Controls
        document.getElementById('clear-deck-btn').addEventListener('click', () => {
            this.clearDeck();
        });

        document.getElementById('auto-build-deck-btn').addEventListener('click', () => {
            this.autoBuildDeck();
        });

        document.getElementById('save-deck-btn').addEventListener('click', () => {
            this.saveDeck();
        });

        // Deck Builder Filters
        document.getElementById('deck-rarity-filter').addEventListener('change', () => {
            this.updateDeckBuilder();
        });

        document.getElementById('deck-sort-filter').addEventListener('change', () => {
            this.updateDeckBuilder();
        });

        // Kampf
        document.getElementById('monster-select').addEventListener('change', (e) => {
            if (e.target.value) {
                this.selectPlayerMonster(e.target.value);
            }
        });

        document.getElementById('attack-btn').addEventListener('click', () => {
            this.performAttack();
        });

        document.getElementById('find-opponent-btn').addEventListener('click', () => {
            this.findOpponent();
        });

        // Modal
        document.querySelector('.close').addEventListener('click', () => {
            document.getElementById('card-modal').style.display = 'none';
        });

        window.addEventListener('click', (e) => {
            if (e.target === document.getElementById('card-modal')) {
                document.getElementById('card-modal').style.display = 'none';
            }
        });
    }

    switchTab(tab) {
        // Tab-Buttons aktualisieren
        document.querySelectorAll('.nav-btn').forEach(btn => {
            btn.classList.remove('active');
        });
        document.querySelector(`[data-tab="${tab}"]`).classList.add('active');

        // Tab-Content aktualisieren
        document.querySelectorAll('.tab-content').forEach(content => {
            content.classList.remove('active');
        });
        document.getElementById(tab).classList.add('active');

        // Spezielle Updates für verschiedene Tabs
        if (tab === 'collection') {
            this.displayCollection();
        } else if (tab === 'battle') {
            this.updateBattleMonsterSelect();
        } else if (tab === 'deck') {
            this.updateDeckBuilder();
        } else if (tab === 'shop') {
            this.updateShopDisplay();
        }
    }

    updateShopDisplay() {
        // Überprüfe ob Displays initialisiert sind
        const basicDisplay = document.querySelector('.basic-display');
        if (!basicDisplay || basicDisplay.children.length === 0) {
            this.initializeBoosterDisplays();
        }
        
        // Update Verfügbarkeit basierend auf Münzen
        this.updatePackAvailability();
        
        // Update Shop-Statistiken
        this.updateShopStats();
    }

    updatePackAvailability() {
        // Basic Packs (50 Münzen)
        document.querySelectorAll('.basic-pack').forEach(pack => {
            if (!pack.classList.contains('sold-out')) {
                if (this.coins < 50) {
                    pack.style.opacity = '0.5';
                    pack.style.cursor = 'not-allowed';
                } else {
                    pack.style.opacity = '1';
                    pack.style.cursor = 'pointer';
                }
            }
        });

        // Premium Packs (100 Münzen)
        document.querySelectorAll('.premium-pack').forEach(pack => {
            if (!pack.classList.contains('sold-out')) {
                if (this.coins < 100) {
                    pack.style.opacity = '0.5';
                    pack.style.cursor = 'not-allowed';
                } else {
                    pack.style.opacity = '1';
                    pack.style.cursor = 'pointer';
                }
            }
        });

        // Legendary Packs (250 Münzen)
        document.querySelectorAll('.legendary-pack').forEach(pack => {
            if (!pack.classList.contains('sold-out')) {
                if (this.coins < 250) {
                    pack.style.opacity = '0.5';
                    pack.style.cursor = 'not-allowed';
                } else {
                    pack.style.opacity = '1';
                    pack.style.cursor = 'pointer';
                }
            }
        });
    }

    buyPack(packType) {
        let cost, cardCount, guaranteedRare;
        
        if (packType === 'basic') {
            cost = 50;
            cardCount = 5;
            guaranteedRare = false;
        } else if (packType === 'premium') {
            cost = 100;
            cardCount = 5;
            guaranteedRare = true;
        } else if (packType === 'legendary') {
            cost = 250;
            cardCount = 3;
            guaranteedRare = 'legendary';
        }

        if (this.coins < cost) {
            this.showSaveIndicator('💸 Nicht genügend Münzen!', 'error');
            return false; // Zeige an, dass der Kauf fehlgeschlagen ist
        }

        this.coins -= cost;
        
        // Karten generieren basierend auf Pack-Typ
        const newCards = this.generatePackCards(packType, cardCount, guaranteedRare);

        // Karten zur Sammlung hinzufügen
        this.collection.push(...newCards);
        
        // Pack-Opening Animation starten
        this.showPackOpening(newCards, packType);
        this.updateDisplay();
        
        return true; // Zeige an, dass der Kauf erfolgreich war
    }

    generatePackCards(packType, cardCount, guaranteedRare) {
        const newCards = [];
        
        if (packType === 'basic') {
            // Basis-Pack: Standard-Wahrscheinlichkeiten
            for (let i = 0; i < cardCount; i++) {
                newCards.push(this.getRandomMonsterByRarity());
            }
        } else if (packType === 'premium') {
            // Premium-Pack: Erste Karte garantiert selten+
            for (let i = 0; i < cardCount; i++) {
                let rarity = null;
                if (i === 0) {
                    // Erste Karte ist garantiert selten oder besser
                    const rand = Math.random();
                    if (rand < 0.6) rarity = "rare";
                    else if (rand < 0.85) rarity = "epic";
                    else rarity = "legendary";
                }
                newCards.push(this.getRandomMonsterByRarity(rarity));
            }
        } else if (packType === 'legendary') {
            // Legendärer Pack: Höhere Qualität, weniger Karten
            for (let i = 0; i < cardCount; i++) {
                let rarity = null;
                if (i === 0) {
                    rarity = "legendary"; // Erste Karte garantiert legendär
                } else {
                    const rand = Math.random();
                    if (rand < 0.5) rarity = "epic";
                    else rarity = "legendary";
                }
                newCards.push(this.getRandomMonsterByRarity(rarity));
            }
        }
        
        return newCards;
    }

    showPackOpening(cards, packType) {
        const modal = document.getElementById('pack-opening');
        const revealedCardsContainer = document.getElementById('revealed-cards');
        const collectBtn = document.getElementById('collect-cards');
        
        // Modal anzeigen
        modal.classList.remove('hidden');
        
        // Container leeren
        revealedCardsContainer.innerHTML = '';
        collectBtn.classList.add('hidden');
        
        // Pack-Type spezifische Nachrichten
        const messages = {
            'basic': '📦 Basis-Booster wird geöffnet...',
            'premium': '✨ Premium-Booster wird geöffnet...',
            'legendary': '🌟 Legendärer Booster wird geöffnet...'
        };
        
        document.querySelector('.pack-opening-content h3').textContent = messages[packType];
        
        // Animation mit Verzögerung
        setTimeout(() => {
            this.revealCards(cards);
        }, 2000);
    }

    revealCards(cards) {
        const revealedCardsContainer = document.getElementById('revealed-cards');
        const collectBtn = document.getElementById('collect-cards');
        
        // Spinner verstecken
        document.querySelector('.opening-animation').style.display = 'none';
        
        // Titel ändern
        document.querySelector('.pack-opening-content h3').textContent = '🎉 Deine neuen Karten!';
        
        // Karten nacheinander enthüllen
        cards.forEach((card, index) => {
            setTimeout(() => {
                const cardElement = document.createElement('div');
                cardElement.className = `revealed-card ${card.rarity}`;
                cardElement.style.animationDelay = `${index * 0.2}s`;
                
                cardElement.innerHTML = `
                    <div class="card-emoji monster-image ${card.image}">
                        <div class="monster-symbol">${card.emoji}</div>
                    </div>
                    <div class="card-name">${card.name}</div>
                    <div class="card-rarity">${this.getRarityText(card.rarity)}</div>
                `;
                
                revealedCardsContainer.appendChild(cardElement);
                
                // Spezielle Effekte für seltene Karten
                if (card.rarity === 'legendary') {
                    this.playLegendaryEffect();
                } else if (card.rarity === 'epic') {
                    this.playEpicEffect();
                }
                
                // Nach der letzten Karte den Sammeln-Button anzeigen
                if (index === cards.length - 1) {
                    setTimeout(() => {
                        collectBtn.classList.remove('hidden');
                        this.setupCollectButton();
                    }, 500);
                }
            }, index * 600);
        });
    }

    getRarityText(rarity) {
        const rarityTexts = {
            'common': 'Häufig',
            'rare': 'Selten',
            'epic': 'Episch',
            'legendary': 'Legendär'
        };
        return rarityTexts[rarity] || 'Unbekannt';
    }

    playLegendaryEffect() {
        // Erstelle temporäre Partikel-Effekte
        const effects = ['✨', '⭐', '🌟', '💫'];
        for (let i = 0; i < 10; i++) {
            setTimeout(() => {
                const particle = document.createElement('div');
                particle.textContent = effects[Math.floor(Math.random() * effects.length)];
                particle.style.position = 'fixed';
                particle.style.left = Math.random() * window.innerWidth + 'px';
                particle.style.top = Math.random() * window.innerHeight + 'px';
                particle.style.fontSize = '2rem';
                particle.style.zIndex = '9999';
                particle.style.pointerEvents = 'none';
                particle.style.animation = 'particle-float 2s ease-out forwards';
                
                document.body.appendChild(particle);
                
                setTimeout(() => {
                    particle.remove();
                }, 2000);
            }, i * 100);
        }
    }

    playEpicEffect() {
        // Bildschirm-Flash-Effekt für epische Karten
        const flash = document.createElement('div');
        flash.style.position = 'fixed';
        flash.style.top = '0';
        flash.style.left = '0';
        flash.style.width = '100vw';
        flash.style.height = '100vh';
        flash.style.background = 'rgba(156, 39, 176, 0.3)';
        flash.style.zIndex = '9998';
        flash.style.pointerEvents = 'none';
        flash.style.animation = 'flash 0.3s ease-out';
        
        document.body.appendChild(flash);
        
        setTimeout(() => {
            flash.remove();
        }, 300);
    }

    setupCollectButton() {
        const collectBtn = document.getElementById('collect-cards');
        
        // Entferne vorherige Event Listener
        collectBtn.replaceWith(collectBtn.cloneNode(true));
        const newCollectBtn = document.getElementById('collect-cards');
        
        newCollectBtn.addEventListener('click', () => {
            // Modal schließen
            document.getElementById('pack-opening').classList.add('hidden');
            
            // Spinner wieder anzeigen für nächstes Mal
            document.querySelector('.opening-animation').style.display = 'block';
            
            // Zur Sammlung wechseln
            this.switchTab('collection');
        });
    }

    displayCollection() {
        const grid = document.getElementById('card-grid');
        const filteredCards = this.getFilteredCards();
        
        grid.innerHTML = '';
        
        filteredCards.forEach(monster => {
            const cardElement = this.createCardElement(monster);
            cardElement.addEventListener('click', () => this.showCardDetails(monster));
            grid.appendChild(cardElement);
        });
    }

    getFilteredCards() {
        let filtered = [...this.collection];
        
        // Seltenheits-Filter
        const rarityFilter = document.getElementById('rarity-filter').value;
        if (rarityFilter !== 'all') {
            filtered = filtered.filter(card => card.rarity === rarityFilter);
        }
        
        // Suchfilter
        const searchTerm = document.getElementById('search-cards').value.toLowerCase();
        if (searchTerm) {
            filtered = filtered.filter(card => 
                card.name.toLowerCase().includes(searchTerm) ||
                card.description.toLowerCase().includes(searchTerm)
            );
        }
        
        return filtered;
    }

    createCardElement(monster, isSmall = false) {
        const card = document.createElement('div');
        card.className = `monster-card ${monster.rarity}`;
        
        card.innerHTML = `
            <div class="card-rarity rarity-${monster.rarity}">${monster.rarity}</div>
            <div class="card-image monster-image ${monster.image}">
                <div class="monster-symbol">${monster.emoji}</div>
            </div>
            <div class="card-name">${monster.name}</div>
            <div class="card-stats">
                <div class="stat-item">
                    <span class="stat-label">Angriff</span>
                    <span class="stat-value">${monster.attack}</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">Verteidigung</span>
                    <span class="stat-value">${monster.defense}</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">Leben</span>
                    <span class="stat-value">${monster.health}/${monster.maxHealth}</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">Typ</span>
                    <span class="stat-value">${monster.rarity}</span>
                </div>
            </div>
            <div class="card-description">${monster.description}</div>
        `;
        
        card.classList.add('card-reveal');
        
        return card;
    }

    showCardDetails(monster) {
        const modal = document.getElementById('card-modal');
        const details = document.getElementById('modal-card-details');
        
        details.innerHTML = `
            <div class="monster-card ${monster.rarity}" style="max-width: none; margin: 20px 0;">
                <div class="card-rarity rarity-${monster.rarity}">${monster.rarity}</div>
                <div class="card-image monster-image ${monster.image}" style="height: 150px;">
                    <div class="monster-symbol" style="font-size: 4rem;">${monster.emoji}</div>
                </div>
                <div class="card-name" style="font-size: 1.5rem;">${monster.name}</div>
                <div class="card-stats">
                    <div class="stat-item">
                        <span class="stat-label">Angriff</span>
                        <span class="stat-value">${monster.attack}</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Verteidigung</span>
                        <span class="stat-value">${monster.defense}</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Leben</span>
                        <span class="stat-value">${monster.health}/${monster.maxHealth}</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Seltenheit</span>
                        <span class="stat-value">${monster.rarity}</span>
                    </div>
                </div>
                <div class="card-description" style="font-size: 1rem; margin-top: 15px;">${monster.description}</div>
            </div>
        `;
        
        modal.style.display = 'block';
    }

    updateBattleMonsterSelect() {
        const select = document.getElementById('monster-select');
        select.innerHTML = '<option value="">Monster wählen...</option>';
        
        this.collection.forEach(monster => {
            if (monster.isAlive()) {
                const option = document.createElement('option');
                option.value = monster.id;
                option.textContent = `${monster.name} (${monster.health}/${monster.maxHealth} HP)`;
                select.appendChild(option);
            }
        });
    }

    selectPlayerMonster(monsterId) {
        this.currentBattleMonster = this.collection.find(m => m.id === monsterId);
        
        if (this.currentBattleMonster) {
            const playerMonsterDiv = document.getElementById('player-monster');
            playerMonsterDiv.innerHTML = '';
            playerMonsterDiv.classList.add('has-monster');
            
            const cardElement = this.createCardElement(this.currentBattleMonster);
            playerMonsterDiv.appendChild(cardElement);
            
            document.getElementById('attack-btn').disabled = !this.enemyMonster;
        }
    }

    findOpponent() {
        // Zufälliges Gegner-Monster generieren
        this.enemyMonster = this.getRandomMonsterByRarity();
        
        const enemyMonsterDiv = document.getElementById('enemy-monster');
        enemyMonsterDiv.innerHTML = '';
        enemyMonsterDiv.classList.add('has-monster');
        
        const cardElement = this.createCardElement(this.enemyMonster);
        enemyMonsterDiv.appendChild(cardElement);
        
        document.getElementById('find-opponent-btn').textContent = 'Neuer Gegner';
        document.getElementById('attack-btn').disabled = !this.currentBattleMonster;
        
        this.addBattleLog(`Wilder ${this.enemyMonster.name} erscheint!`);
    }

    performAttack() {
        if (!this.currentBattleMonster || !this.enemyMonster || this.battleInProgress) return;
        
        this.battleInProgress = true;
        
        // Spieler greift an
        const playerDamage = this.currentBattleMonster.attack;
        const actualDamage = this.enemyMonster.takeDamage(playerDamage);
        
        this.addBattleLog(`${this.currentBattleMonster.name} greift an und verursacht ${actualDamage} Schaden!`);
        
        // Prüfen ob Gegner besiegt wurde
        if (!this.enemyMonster.isAlive()) {
            this.addBattleLog(`${this.enemyMonster.name} wurde besiegt! Du gewinnst!`);
            this.coins += 25;
            this.updateDisplay();
            
            // Speichere nach Kampf-Sieg
            this.saveGameData();
            
            this.resetBattle();
            return;
        }
        
        // Gegner greift zurück
        setTimeout(() => {
            const enemyDamage = this.enemyMonster.attack;
            const actualDamage = this.currentBattleMonster.takeDamage(enemyDamage);
            
            this.addBattleLog(`${this.enemyMonster.name} greift zurück und verursacht ${actualDamage} Schaden!`);
            
            // Karten-Display aktualisieren
            this.updateBattleDisplay();
            
            // Prüfen ob Spieler-Monster besiegt wurde
            if (!this.currentBattleMonster.isAlive()) {
                this.addBattleLog(`${this.currentBattleMonster.name} wurde besiegt! Du verlierst...`);
                this.resetBattle();
                return;
            }
            
            this.battleInProgress = false;
        }, 1000);
    }

    updateBattleDisplay() {
        if (this.currentBattleMonster) {
            const playerMonsterDiv = document.getElementById('player-monster');
            playerMonsterDiv.innerHTML = '';
            const cardElement = this.createCardElement(this.currentBattleMonster);
            playerMonsterDiv.appendChild(cardElement);
        }
        
        if (this.enemyMonster) {
            const enemyMonsterDiv = document.getElementById('enemy-monster');
            enemyMonsterDiv.innerHTML = '';
            const cardElement = this.createCardElement(this.enemyMonster);
            enemyMonsterDiv.appendChild(cardElement);
        }
    }

    addBattleLog(message) {
        const log = document.getElementById('battle-log');
        const logEntry = document.createElement('div');
        logEntry.textContent = `> ${message}`;
        log.appendChild(logEntry);
        log.scrollTop = log.scrollHeight;
    }

    resetBattle() {
        this.currentBattleMonster = null;
        this.enemyMonster = null;
        this.battleInProgress = false;
        
        document.getElementById('player-monster').innerHTML = '';
        document.getElementById('player-monster').classList.remove('has-monster');
        document.getElementById('enemy-monster').innerHTML = '';
        document.getElementById('enemy-monster').classList.remove('has-monster');
        document.getElementById('monster-select').value = '';
        document.getElementById('attack-btn').disabled = true;
        document.getElementById('find-opponent-btn').textContent = 'Gegner finden';
        
        // Alle Monster heilen
        this.collection.forEach(monster => monster.heal());
        this.updateBattleMonsterSelect();
        
        // Speichere nach Kampf-Reset (Heilung)
        this.saveGameData();
    }

    filterCards() {
        this.displayCollection();
    }

    updateDeckBuilder() {
        // Update Deck-Anzeige
        this.displayCurrentDeck();
        
        // Update verfügbare Karten
        this.displayDeckBuilderCards();
        
        // Update Deck-Analyse
        this.updateDeckAnalysis();
    }

    displayCurrentDeck() {
        const deckContainer = document.getElementById('deck-cards');
        const deckCountElement = document.getElementById('deck-count');
        
        // Update Deck-Count
        if (deckCountElement) {
            deckCountElement.textContent = this.deck.length;
        }
        
        if (this.deck.length === 0) {
            deckContainer.innerHTML = `
                <div class="empty-deck-message">
                    <div class="empty-icon">🎴</div>
                    <p>Dein Deck ist leer!</p>
                    <p class="empty-hint">Klicke auf Karten aus deiner Sammlung, um sie hinzuzufügen.</p>
                </div>
            `;
            return;
        }
        
        deckContainer.innerHTML = '';
        
        this.deck.forEach((monster, index) => {
            const cardElement = this.createDeckCardElement(monster, index);
            deckContainer.appendChild(cardElement);
        });
    }

    createDeckCardElement(monster, index) {
        const card = document.createElement('div');
        card.className = `deck-card monster-card ${monster.rarity}`;
        
        card.innerHTML = `
            <button class="remove-from-deck" onclick="game.removeFromDeck(${index})" title="Aus Deck entfernen">×</button>
            <div class="card-rarity rarity-${monster.rarity}">${monster.rarity}</div>
            <div class="card-image monster-image ${monster.image}">
                <div class="monster-symbol">${monster.emoji}</div>
            </div>
            <div class="card-name">${monster.name}</div>
            <div class="card-stats">
                <div class="stat-item">
                    <span class="stat-label">ATK</span>
                    <span class="stat-value">${monster.attack}</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">DEF</span>
                    <span class="stat-value">${monster.defense}</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">HP</span>
                    <span class="stat-value">${monster.health}</span>
                </div>
            </div>
        `;
        
        return card;
    }

    displayDeckBuilderCards() {
        const container = document.getElementById('deck-builder-cards');
        const filteredCards = this.getFilteredDeckBuilderCards();
        
        container.innerHTML = '';
        
        filteredCards.forEach(monster => {
            const cardElement = this.createDeckBuilderCardElement(monster);
            container.appendChild(cardElement);
        });
    }

    getFilteredDeckBuilderCards() {
        let filtered = [...this.collection];
        
        // Seltenheits-Filter
        const rarityFilter = document.getElementById('deck-rarity-filter')?.value || 'all';
        if (rarityFilter !== 'all') {
            filtered = filtered.filter(card => card.rarity === rarityFilter);
        }
        
        // Sortierung
        const sortFilter = document.getElementById('deck-sort-filter')?.value || 'name';
        filtered.sort((a, b) => {
            switch(sortFilter) {
                case 'attack':
                    return b.attack - a.attack;
                case 'defense':
                    return b.defense - a.defense;
                case 'health':
                    return b.maxHealth - a.maxHealth;
                case 'rarity':
                    const rarityOrder = { common: 1, rare: 2, epic: 3, legendary: 4 };
                    return rarityOrder[b.rarity] - rarityOrder[a.rarity];
                case 'name':
                default:
                    return a.name.localeCompare(b.name);
            }
        });
        
        return filtered;
    }

    createDeckBuilderCardElement(monster) {
        const card = document.createElement('div');
        const isInDeck = this.deck.some(deckCard => deckCard.id === monster.id);
        
        card.className = `deck-builder-card monster-card ${monster.rarity}`;
        if (isInDeck) {
            card.classList.add('in-deck');
        }

        // Drag & Drop Funktionalität hinzufügen
        card.draggable = true;
        card.dataset.monsterId = monster.id;
        
        card.innerHTML = `
            <div class="card-rarity rarity-${monster.rarity}">${monster.rarity}</div>
            <div class="card-image monster-image ${monster.image}">
                <div class="monster-symbol">${monster.emoji}</div>
            </div>
            <div class="card-name">${monster.name}</div>
            <div class="card-stats">
                <div class="stat-item">
                    <span class="stat-label">ATK</span>
                    <span class="stat-value">${monster.attack}</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">DEF</span>
                    <span class="stat-value">${monster.defense}</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">HP</span>
                    <span class="stat-value">${monster.health}</span>
                </div>
            </div>
            ${!isInDeck ? `<button class="add-to-deck-btn" onclick="game.addToDeck('${monster.id}')" title="Zum Deck hinzufügen">+</button>` : ''}
        `;

        // Drag Event Listeners
        card.addEventListener('dragstart', (e) => {
            if (!isInDeck) {
                e.dataTransfer.setData('text/plain', monster.id);
                card.classList.add('dragging');
            } else {
                e.preventDefault();
            }
        });

        card.addEventListener('dragend', () => {
            card.classList.remove('dragging');
        });
        
        // Karten-Details bei Klick anzeigen
        card.addEventListener('click', (e) => {
            if (!e.target.classList.contains('add-to-deck-btn')) {
                this.showCardDetails(monster);
            }
        });
        
        return card;
    }

    initializeDragAndDrop() {
        const deckCardsContainer = document.getElementById('deck-cards');
        
        // Drop Zone für das Deck
        deckCardsContainer.addEventListener('dragover', (e) => {
            e.preventDefault();
            deckCardsContainer.classList.add('drag-over');
        });

        deckCardsContainer.addEventListener('dragleave', (e) => {
            if (!deckCardsContainer.contains(e.relatedTarget)) {
                deckCardsContainer.classList.remove('drag-over');
            }
        });

        deckCardsContainer.addEventListener('drop', (e) => {
            e.preventDefault();
            deckCardsContainer.classList.remove('drag-over');
            
            const monsterId = e.dataTransfer.getData('text/plain');
            if (monsterId) {
                this.addToDeck(monsterId);
            }
        });
    }

    addToDeck(monsterId) {
        if (this.deck.length >= this.maxDeckSize) {
            this.showSaveIndicator(`⚠️ Deck ist voll! Maximum: ${this.maxDeckSize} Karten`, 'error');
            return;
        }
        
        const monster = this.collection.find(m => m.id === monsterId);
        if (!monster) return;
        
        // Prüfe ob Karte bereits im Deck ist
        if (this.deck.some(deckCard => deckCard.id === monsterId)) {
            this.showSaveIndicator('⚠️ Karte ist bereits im Deck!', 'error');
            return;
        }
        
        // Füge Karte zum Deck hinzu
        this.deck.push(monster);
        
        // Update Displays
        this.updateDeckBuilder();
        
        // Speichere Änderungen
        this.saveGameData();
        
        this.showSaveIndicator(`✅ ${monster.name} zum Deck hinzugefügt!`, 'success');
    }

    removeFromDeck(index) {
        if (index >= 0 && index < this.deck.length) {
            const removedMonster = this.deck.splice(index, 1)[0];
            
            // Update Displays
            this.updateDeckBuilder();
            
            // Speichere Änderungen
            this.saveGameData();
            
            this.showSaveIndicator(`🗑️ ${removedMonster.name} aus Deck entfernt!`, 'success');
        }
    }

    clearDeck() {
        if (this.deck.length === 0) {
            this.showSaveIndicator('⚠️ Deck ist bereits leer!', 'error');
            return;
        }
        
        if (confirm('🗑️ Möchtest du wirklich das gesamte Deck leeren?')) {
            this.deck = [];
            this.updateDeckBuilder();
            this.saveGameData();
            this.showSaveIndicator('🗑️ Deck wurde geleert!', 'success');
        }
    }

    autoBuildDeck() {
        if (this.collection.length < this.maxDeckSize) {
            this.showSaveIndicator('⚠️ Nicht genügend Karten für Auto-Build!', 'error');
            return;
        }
        
        // Leere aktuelles Deck
        this.deck = [];
        
        // Sortiere Karten nach Power (Angriff + Verteidigung + Gesundheit)
        const sortedCards = [...this.collection].sort((a, b) => {
            const powerA = a.attack + a.defense + a.maxHealth;
            const powerB = b.attack + b.defense + b.maxHealth;
            return powerB - powerA;
        });
        
        // Nehme die besten Karten, aber achte auf Balance
        const rarityLimits = {
            legendary: Math.min(3, Math.floor(this.maxDeckSize * 0.3)),
            epic: Math.min(3, Math.floor(this.maxDeckSize * 0.3)),
            rare: Math.min(4, Math.floor(this.maxDeckSize * 0.4)),
            common: this.maxDeckSize
        };
        
        const deckByRarity = { legendary: [], epic: [], rare: [], common: [] };
        
        // Verteile Karten nach Seltenheit
        for (const card of sortedCards) {
            if (deckByRarity[card.rarity].length < rarityLimits[card.rarity]) {
                deckByRarity[card.rarity].push(card);
            }
        }
        
        // Fülle Deck mit den besten Karten jeder Seltenheit
        this.deck = [
            ...deckByRarity.legendary,
            ...deckByRarity.epic,
            ...deckByRarity.rare,
            ...deckByRarity.common
        ].slice(0, this.maxDeckSize);
        
        this.updateDeckBuilder();
        this.saveGameData();
        this.showSaveIndicator('🤖 Auto-Build abgeschlossen!', 'success');
    }

    saveDeck() {
        if (this.deck.length === 0) {
            this.showSaveIndicator('⚠️ Deck ist leer - nichts zu speichern!', 'error');
            return;
        }
        
        this.saveGameData();
        this.showSaveIndicator('💾 Deck erfolgreich gespeichert!', 'success');
    }

    updateDeckAnalysis() {
        if (this.deck.length === 0) {
            this.resetDeckAnalysis();
            return;
        }
        
        // Berechne Durchschnittswerte
        const totalAttack = this.deck.reduce((sum, card) => sum + card.attack, 0);
        const totalDefense = this.deck.reduce((sum, card) => sum + card.defense, 0);
        const totalHealth = this.deck.reduce((sum, card) => sum + card.maxHealth, 0);
        
        const avgAttack = Math.round(totalAttack / this.deck.length);
        const avgDefense = Math.round(totalDefense / this.deck.length);
        const avgHealth = Math.round(totalHealth / this.deck.length);
        
        // Update Durchschnittswerte
        const avgAttackElement = document.getElementById('avg-attack');
        const avgDefenseElement = document.getElementById('avg-defense');
        const avgHealthElement = document.getElementById('avg-health');
        
        if (avgAttackElement) avgAttackElement.textContent = avgAttack;
        if (avgDefenseElement) avgDefenseElement.textContent = avgDefense;
        if (avgHealthElement) avgHealthElement.textContent = avgHealth;
        
        // Update Deck-Power
        const deckPower = totalAttack + totalDefense + totalHealth;
        const deckPowerElement = document.getElementById('deck-power');
        if (deckPowerElement) {
            deckPowerElement.textContent = deckPower;
            
            // Füge Deck-Qualitäts-Indikator hinzu
            this.updateDeckQualityIndicator(deckPower, this.deck.length);
        }
        
        // Update Seltenheits-Verteilung
        const rarityCount = { common: 0, rare: 0, epic: 0, legendary: 0 };
        this.deck.forEach(card => {
            rarityCount[card.rarity]++;
        });
        
        Object.keys(rarityCount).forEach(rarity => {
            const countElement = document.getElementById(`${rarity}-count`);
            const barElement = document.getElementById(`${rarity}-bar`);
            
            if (countElement) countElement.textContent = rarityCount[rarity];
            if (barElement) {
                const percentage = (rarityCount[rarity] / this.deck.length) * 100;
                barElement.style.width = `${percentage}%`;
            }
        });
    }

    resetDeckAnalysis() {
        // Reset alle Werte auf 0
        ['avg-attack', 'avg-defense', 'avg-health', 'deck-power'].forEach(id => {
            const element = document.getElementById(id);
            if (element) element.textContent = '0';
        });
        
        ['common', 'rare', 'epic', 'legendary'].forEach(rarity => {
            const countElement = document.getElementById(`${rarity}-count`);
            const barElement = document.getElementById(`${rarity}-bar`);
            
            if (countElement) countElement.textContent = '0';
            if (barElement) barElement.style.width = '0%';
        });
    }

    // Display und Update Funktionen
    updateDisplay() {
        document.getElementById('coins').textContent = this.coins;
        document.getElementById('card-count').textContent = this.collection.length;
        
        // Update Collection Statistics
        this.updateCollectionStats();
    }

    updateCollectionStats() {
        const rarityCount = { common: 0, rare: 0, epic: 0, legendary: 0 };
        
        this.collection.forEach(card => {
            rarityCount[card.rarity]++;
        });
        
        // Update collection header stats if they exist
        Object.keys(rarityCount).forEach(rarity => {
            const element = document.getElementById(`collection-${rarity}-count`);
            if (element) {
                element.textContent = rarityCount[rarity];
            }
        });
    }

    // Save/Load System
    loadGameData() {
        try {
            const savedData = localStorage.getItem('monsterTCG-gameData');
            if (savedData) {
                const data = JSON.parse(savedData);
                
                this.coins = data.coins || 100;
                this.collection = data.collection ? data.collection.map(cardData => 
                    new Monster(cardData.name, cardData.emoji, cardData.attack, 
                               cardData.defense, cardData.maxHealth, cardData.rarity, cardData.description)
                ) : [];
                
                this.deck = data.deck ? data.deck.map(cardData => 
                    new Monster(cardData.name, cardData.emoji, cardData.attack, 
                               cardData.defense, cardData.maxHealth, cardData.rarity, cardData.description)
                ) : [];
                
                // Wenn keine Sammlung vorhanden, Starter-Karten initialisieren
                if (this.collection.length === 0) {
                    this.initializeStarterCards();
                }
            } else {
                // Neues Spiel - Starter-Karten initialisieren
                this.initializeStarterCards();
            }
        } catch (error) {
            console.warn('Fehler beim Laden der Spielstände:', error);
            this.initializeStarterCards();
        }
    }

    saveGameData() {
        try {
            const gameData = {
                coins: this.coins,
                collection: this.collection.map(card => ({
                    name: card.name,
                    emoji: card.emoji,
                    attack: card.attack,
                    defense: card.defense,
                    maxHealth: card.maxHealth,
                    rarity: card.rarity,
                    description: card.description
                })),
                deck: this.deck.map(card => ({
                    name: card.name,
                    emoji: card.emoji,
                    attack: card.attack,
                    defense: card.defense,
                    maxHealth: card.maxHealth,
                    rarity: card.rarity,
                    description: card.description
                })),
                lastSaved: new Date().toISOString()
            };
            
            localStorage.setItem('monsterTCG-gameData', JSON.stringify(gameData));
            this.updateSaveStatus();
        } catch (error) {
            console.error('Fehler beim Speichern:', error);
        }
    }

    startAutoSave() {
        // Auto-Save alle 10 Sekunden
        this.autoSaveInterval = setInterval(() => {
            this.saveGameData();
        }, 10000);
    }

    manualSave() {
        this.saveGameData();
        this.showSaveIndicator('💾 Spiel manuell gespeichert!', 'success');
    }

    exportSaveData() {
        try {
            const gameData = {
                coins: this.coins,
                collection: this.collection,
                deck: this.deck,
                exportDate: new Date().toISOString()
            };
            
            const dataStr = JSON.stringify(gameData, null, 2);
            const dataBlob = new Blob([dataStr], {type: 'application/json'});
            
            const link = document.createElement('a');
            link.href = URL.createObjectURL(dataBlob);
            link.download = `monster-tcg-save-${new Date().toISOString().split('T')[0]}.json`;
            link.click();
            
            this.showSaveIndicator('📤 Spielstand exportiert!', 'success');
        } catch (error) {
            this.showSaveIndicator('❌ Export fehlgeschlagen!', 'error');
        }
    }

    importSaveData(file) {
        if (!file) return;
        
        const reader = new FileReader();
        reader.onload = (e) => {
            try {
                const data = JSON.parse(e.target.result);
                
                this.coins = data.coins || 100;
                this.collection = data.collection || [];
                this.deck = data.deck || [];
                
                this.updateDisplay();
                this.updateDeckBuilder();
                this.saveGameData();
                
                this.showSaveIndicator('📥 Spielstand importiert!', 'success');
            } catch (error) {
                this.showSaveIndicator('❌ Import fehlgeschlagen!', 'error');
            }
        };
        reader.readAsText(file);
    }

    resetGame() {
        if (confirm('🔄 Möchtest du wirklich das komplette Spiel zurücksetzen? Alle Fortschritte gehen verloren!')) {
            localStorage.removeItem('monsterTCG-gameData');
            location.reload();
        }
    }

    updateSaveStatus() {
        const saveTimeElement = document.getElementById('last-save-time');
        if (saveTimeElement) {
            const now = new Date();
            saveTimeElement.textContent = now.toLocaleTimeString();
        }
    }

    showSaveIndicator(message, type = 'success') {
        // Erstelle Save-Indikator Element falls es nicht existiert
        let indicator = document.getElementById('save-indicator');
        if (!indicator) {
            indicator = document.createElement('div');
            indicator.id = 'save-indicator';
            indicator.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                padding: 12px 20px;
                border-radius: 8px;
                font-weight: bold;
                z-index: 10000;
                transition: all 0.3s ease;
                transform: translateX(400px);
            `;
            document.body.appendChild(indicator);
        }
        
        // Styling basierend auf Typ
        if (type === 'success') {
            indicator.style.background = 'linear-gradient(45deg, #4CAF50, #45a049)';
            indicator.style.color = 'white';
        } else if (type === 'error') {
            indicator.style.background = 'linear-gradient(45deg, #f44336, #d32f2f)';
            indicator.style.color = 'white';
        }
        
        indicator.textContent = message;
        indicator.style.transform = 'translateX(0)';
        
        // Nach 3 Sekunden ausblenden
        setTimeout(() => {
            indicator.style.transform = 'translateX(400px)';
        }, 3000);
    }

    // Booster Display Funktionen
    initializeBoosterDisplays() {
        // Generiere 30 Booster für jeden Typ
        this.generateBoosterDisplay('basic', 30);
        this.generateBoosterDisplay('premium', 30);
        this.generateBoosterDisplay('legendary', 30);
    }

    generateBoosterDisplay(packType, count) {
        const display = document.querySelector(`.${packType}-display`);
        if (!display) return;
        
        display.innerHTML = '';
        
        for (let i = 0; i < count; i++) {
            const pack = this.createDisplayPack(packType, i);
            display.appendChild(pack);
        }
    }

    createDisplayPack(packType, index) {
        const pack = document.createElement('div');
        pack.className = `display-pack ${packType}-pack`;
        pack.dataset.packType = packType;
        pack.dataset.packIndex = index;
        
        // Pack-spezifische Icons mit CSS-Klassen
        const packIcons = {
            'basic': '<div class="pack-icon pack-basic">📦</div>',
            'premium': '<div class="pack-icon pack-premium">✨</div>',
            'legendary': '<div class="pack-icon pack-legendary">🌟</div>'
        };
        
        pack.innerHTML = `
            ${packIcons[packType]}
            <div class="pack-number">#${index + 1}</div>
        `;
        
        pack.addEventListener('click', () => {
            if (!pack.classList.contains('sold-out')) {
                this.buyPackFromDisplay(packType, pack);
            }
        });
        
        return pack;
    }

    buyPackFromDisplay(packType, packElement) {
        // Prüfe zuerst ob genügend Münzen vorhanden sind
        let cost;
        if (packType === 'basic') cost = 50;
        else if (packType === 'premium') cost = 100;
        else if (packType === 'legendary') cost = 250;
        
        if (this.coins < cost) {
            this.showPurchaseIndicator(`💸 Nicht genügend Münzen! Benötigt: ${cost}`, 'error');
            // Shaking Animation für nicht genügend Münzen
            packElement.style.animation = 'pack-denied 0.5s ease-in-out';
            setTimeout(() => {
                packElement.style.animation = '';
            }, 500);
            return;
        }
        
        // Purchase Animation hinzufügen
        packElement.classList.add('purchasing');
        
        // Nach kurzer Animation das Pack kaufen
        setTimeout(() => {
            // Erst Pack kaufen
            const purchaseSuccess = this.buyPack(packType);
            
            if (purchaseSuccess) {
                // Pack als verkauft markieren
                packElement.classList.remove('purchasing');
                packElement.classList.add('sold-out');
                packElement.innerHTML = `
                    <div class="pack-icon sold">❌</div>
                    <div class="pack-status">Verkauft</div>
                `;
                
                // Shop-Statistiken aktualisieren
                this.updateShopStats();
                
                this.showPurchaseIndicator(`${this.getPackTypeName(packType)} gekauft!`, 'success');
            } else {
                // Bei Fehler Animation entfernen
                packElement.classList.remove('purchasing');
            }
        }, 600);
    }

    getPackTypeName(packType) {
        const names = {
            'basic': 'Basis-Booster',
            'premium': 'Premium-Booster',
            'legendary': 'Legendärer Booster'
        };
        return names[packType] || 'Booster';
    }

    showPurchaseIndicator(message, type = 'success') {
        if (type === 'success') {
            // Erstelle eine spezielle Purchase Success Anzeige
            const indicator = document.createElement('div');
            indicator.className = 'pack-purchase-success';
            indicator.innerHTML = `✅ ${message}`;
            document.body.appendChild(indicator);
            
            // Entferne nach Animation
            setTimeout(() => {
                if (indicator.parentNode) {
                    indicator.parentNode.removeChild(indicator);
                }
            }, 2500);
        } else {
            // Für Fehler verwende das normale System
            this.showSaveIndicator(message, type);
        }
    }

    restockBoosterDisplays() {
        this.initializeBoosterDisplays();
        this.showSaveIndicator('🔄 Alle Booster-Displays wurden aufgefüllt!', 'success');
    }

    updateShopStats() {
        // Zähle verfügbare Packs
        const basicAvailable = document.querySelectorAll('.basic-pack:not(.sold-out)').length;
        const premiumAvailable = document.querySelectorAll('.premium-pack:not(.sold-out)').length;
        const legendaryAvailable = document.querySelectorAll('.legendary-pack:not(.sold-out)').length;
        
        // Update UI falls Shop-Stats-Elemente existieren
        const basicCountElement = document.getElementById('basic-pack-count');
        const premiumCountElement = document.getElementById('premium-pack-count');
        const legendaryCountElement = document.getElementById('legendary-pack-count');
        
        if (basicCountElement) basicCountElement.textContent = basicAvailable;
        if (premiumCountElement) premiumCountElement.textContent = premiumAvailable;
        if (legendaryCountElement) legendaryCountElement.textContent = legendaryAvailable;
    }
}

// Initialize the game
const game = new Game();